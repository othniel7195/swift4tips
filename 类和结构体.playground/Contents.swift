//: Playground - noun: a place where people can play

import UIKit

//类和结构体对比
//Swift 中类和结构体有很多共同点。共同处在于：
//
//定义属性用于存储值
//定义方法用于提供功能
//定义下标操作使得可以通过下标语法来访问实例所包含的值
//定义构造器用于生成初始化值
//通过扩展以增加默认实现的功能
//实现协议以提供某种标准功能
//
//与结构体相比，类还有如下的附加功能：
//
//继承允许一个类继承另一个类的特征
//类型转换允许在运行时检查和解释一个类实例的类型
//析构器允许一个类实例释放任何其所被分配的资源
//引用计数允许对一个类的多次引用
//
//注意
//结构体总是通过被复制的方式在代码中传递，不使用引用计数。



//定义语法
class SomeClass {
    // 在这里定义类
}
struct SomeStructure {
    // 在这里定义结构体
}

//结构体和枚举是值类型
//值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝
//所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现
//在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制


//类是引用类型

//恒等运算符
//等价于（===）
//不等价于（!==）
//运用这两个运算符检测两个常量或者变量是否引用同一个实例
//注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同：
//
//“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。
//“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。
//当你在定义你的自定义类和结构体的时候，你有义务来决定判定两个实例“相等”的标准


//类和结构体的选择
//结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。
//
//按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：
//
//该数据结构的主要目的是用来封装少量相关简单数据值。
//有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。
//该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。
//该数据结构不需要去继承另一个既有类型的属性或者行为。
//举例来说，以下情境中适合使用结构体：
//
//几何形状的大小，封装一个width属性和height属性，两者均为Double类型。
//一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。
//三维坐标系内一点，封装x，y和z属性，三者均为Double类型。
//在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。



//字符串、数组、和字典类型的赋值与复制行为
//Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。
//
//Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。
//
//注意
//以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。
